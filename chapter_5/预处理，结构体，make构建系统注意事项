1.预处理不是C语言一部分，所以不需要分号来结束
2.宏的作用范围是从宏定义开始到本源程序文件结束为止，也可以使用 #undef来提前终止作用范围
3.宏定义可以嵌套，宏参数最好用括号括起来
4.宏次数多时，宏替换后源程序一般会变长，函数调用不会变长。宏替换不会占用运行时间，只是编译时间稍长，而函数调用占用运行时间
5.声明机构体也是C语言语句，因此要已分号作为该语句的结束
6.结构体中成员是按顺序连续存放在内存中的
7.内存为了提高访问效率采用字节对齐 如：
struct person {
    char name[20],
    int age,
    char sex,
    char phone[16]
}
实际分配44个字节

8.结构体中可以有数组类型的成员，数组的元素也可以是结构体。
9.结构体指针所保存的值是它所指向的结构体变量所占内存的首地址
10.共用体中的变量共享同一块内存
11.共用体变量的长度取决于其成员的最大长度
12.不能把共用体变量作为函数参数，也不能使函数返回共用体变量，但可以使用指向共用体变量的指针。
13.typedef 为已存在的数据类型声明别名.如 typedef int NUMBER[10];  NUMBER n; n[0]=0; NUMBER声明为含有10个整形元素的数组
14.C语言允许在一个结构体中以位为单位来使用内存，这种以位为单位的成员称为位域或位段
15.位域内存分配问题如：
// 示例1
struct big_data
{
int a:6;
int b:4;
int c:4;
int d;
}

0-5的6位用于存放变量a,6-9的4位用于存放b,10-13的4位用于存放变量c,14-31的18位空闲,32-63的32位用于存放变量d.

// 示例2
struct big_data
{
int a:6;
int b:4;
int :0;
int c:4;
int d;
}
0-5的6位用于存放变量a,6-9的4位用于存放b, c从下一个存储单元开始存放（32-35），10-31空闲

// 示例3
struct big_data
{
int a:6;
int b:4;
int :8;
int c:4;
int d;
}

0-5的6位用于存放变量a,6-9的4位用于存放b,10-17的8位强制空闲，18-21的4位存放成员c,22-31位的10位空闲，32-63的32位存放d

16.在Linux中，有一个用来维护程序模块关系和生成可执行程序的工具--make。它可以根据Makefile或makefile文件中定义的编译规则（模块
间依赖关系，指定文件的编译顺序以及编译所使用的指令），重新编译链接生成中间代码或可执行程序
17.Makefile的基本构成
Makefile文件的基本单元是规则。一条规则指定一个或多个目标文件，目标文件后面跟的是编译生成该目标文件所依赖的文件或模块，最后是生成或更新目标文件所使用的命令.
规则的格式如下:(如果某一行已Tab开头make就认为这一行是一条命令)
目标文件列表  分隔符 依赖文件列表[; 命令]
    [命令]
    [命令]

18.make 可以通过 -f othername 或 --file=othername 指定makefile文件名字

19.一个完整的Makefile文件由5部分构成：显式规则，隐含规则，使用变量 ，文件指示和注释










