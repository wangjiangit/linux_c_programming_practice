线程的概念：线程是计算机中独立运行的最小单位，系统会给每个线程分配一个时间片，每个线程都在给它分配好的时间片内取得CPU的控制权，执行线程中的代码。
既然有每个线程这个概念，可见线程不是只能有一个。Linux操作系统支持多线程，它在一个进程内生成了许多个线程。一个进程可以拥有一至多个线程。多线程的特别之处：
同一进程内的线程共享进程的地址空间
线程间的切换速度超级快，比进程间的切换速度快多了
线程间的通信又方便又省时（因为共享数据空间）
线程与进程内的线程共享程序代码，一段代码可以同时被多个线程执行。

线程终止：
*linux提供了一对函数pthread_cleanup_push 和pthread_cleanup_pop用于自动释放资源,从pthread_clean_push调用点到到
pthread_cleanup_pop之间的程序段有终止动作（如pthread_exit）执行pthread_clean_push指定的清理函数
*一个join的线程所占用的的内存仅当有线程对其执行了pthread_join后才释放，因此为了避免内存泄漏，所有线程终止时，要么已被设置成DETACHED,要么使用pthread_join（）进行回收
*一个线程不能被多个线程进行等待，否则第一个接受到信号的线程成功返回，其余的调用pthread_join（） 线程返回错误码ESRCH

线程同步：
线程最大的特点是资源的共享性，而资源共享性解决方案有：
互斥锁，条件变量 和异步型号

互斥锁：互斥锁通过锁机制来实现线程间同步，在同一时刻它通常只允许一个线程执行一个关键部分的代码

条件变量：条件变量使我们可以睡眠等待某种条件出现。
条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：
一个线程等待"条件变量的条件成立"而挂起；
另一个线程使"条件成立"（给出条件成立信号）。
为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。
注销一个条件变量需要调用pthread_cond_destroy()，只有在没有线程在该条件变量上等待的时候，才能注销这个条件变量，否则返回EBUS

异步信号:
信号可以被进程用来相互通信。线程同进程一样也可以接收和处理信号，信号也是一种线程间同步的手段。
信号（SIGINT 和 SIGNO）与任何线程都是异步的，也就是说信号达到线程的时间是不确定的。如果有多个线程可以接收
异步信号，则只有一个被选中。如果并发的多个同样的信号被送到一个进程，每一个将被不同的线程处理。如果所有的
线程都屏蔽该信号，则这些信号将被挂起，直到有信号解除屏蔽来处理他们。
处理异步信号的3个函数：
1、int pthread_kill(pthread_t thread, int sig);
向特定的线程发送sig信号
2、int sigwait(const sigset_t *set, int *sig)
阻塞线程，等待set中指定的信号之一到达，并将到达的信号存入sig中
3、int pthread_sigmask (int how,const sigset_t *set,sigset_t *oset)
设置线程的信号屏蔽码，但对不允许屏蔽的信号Cancel信号和不允许响应的信号Restart信号进行了保护。
