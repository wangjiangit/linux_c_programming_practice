

  1.线程与进程概念
  线程： 每个进程中至少包含一个线程，而这些线程都在共享进程的资源空间等，当线程发生变化的时候只会引起CPU执行的过程发生变化，不会改变进程所拥有的资源。同理一个程序中至少包含一个进程。进程中执行运算的最小单位，亦是执行处理机调度的基本单位
  进程： 每个进程都有自己的地址空间，资源如，内存，I/O,CPU，同一个进程里的 线程共享本进程里的地址空间，那能不能使用别人家进程的地址空间呢，显然这是不可以的。由于进程的独立性，当某一个进程崩溃之后，在保护模式下不会对别的进程进行影响。资源分配的基本单位，运行调度的基本单位，系统中并发执行的单位。
  2.使用区别
  当我们对资源的保护管理要求比较高的时候，建议使用多进程，当然存在的开销也会比较大，反过来，如果频繁切换下，对资源的保护管理要求不那么高，或者开销有限，使用多线程会比较方便。
  3.两者的比较
  （1）调度
  同一个进程中，线程的切换不会引起进程的切换；
  由一个进程的线程切换到另一个线程的进程时，引起进程的切换。
  （2）并发性
  进程可以并发执行，而一个进程中的线程也可以并发执行
  （3）拥有的资源
  一般来说，线程并不会拥有自己的资源，但是它可以访问自己本进程中的资源，比如，一个进程打开的文件等，进程的其他线程是可以共享的。
  4.进程是操作系统资源管理的最小单位，有标识号（非负整数）
  6.进程结构
    * 代码段 存储程序的可执行代码
    * 数据段 存放全局变量，常量，静态变量
    * 堆栈段 堆用于存放动态分配的内存变量， 栈用于存放函数参数，局部变量
  7.进程状态：
    R (运行状态)
    S（可中断等待状态）
    D(不可中断等待状态)
    T(停止状态)
    附加属性：<(高优先级进程) N（低优先级进程）L(内存锁页，即页不可以换出内存) s(该进程为会话首进程) l(多线程进程) +(进程位于前台进程)
 8.进程的内存映像
    从内存的低地址到高地址：代码段-》数据段-》未被初始化的数据段-》堆栈-》命令行参数和环境量
 9.孤儿进程
      如果一个子进程的父进程先于子进程结束，子进程就成为一个孤儿进程，它由init进程收养，称为init进程的子进程
 fork和vfork 区别：
     调用都有2次返回值
     fork子进程是父进程的一个拷贝。具体说，子进程从父进程那得到了数据段和堆栈段，但不是与父进程共享而是单独分配内存。fork函数返回后，子进程和父进程都是从fork函数的下一条语句开始执行。
     由于子进程与父进程的运行是无关的，父进程可先于子进程运行，子进程也可先于父进程运行
     vfork创建新进程的主要目的在于用exec函数执行另外的程序，实际上，在没调用exec或exit之前子进程的运行中是与父进程共享数据段的。
     在vfork调用中，子进程先运行，父进程挂起，直到子进程调用exec或exit，在这以后，父子进程的执行顺序不再有限制。vfork执行过程为：它产生的子进程刚开始暂时与父进程共享地址空间（其实就是线程的概念了），因为这时候子进程在父进程的地址空间中运行，所以子进程不能进行写操作，并且在儿子“霸占”着老子的房子时候，要委屈老子一下了，让他在外面歇着（阻塞），一旦儿子执行了exec或者exit后，相当于儿子买了自己的房子了，这时候就相当于分家了。
10.创建守护进程
     让进程在后台执行：方法是调用fork产生一个子进程，然后使得父进程退出
     调用setid创建一个新对话期。控制终端，登陆会话和进程组通常师父进程继承下来的，守护进程要摆脱它们，不受它们的影响，其方法是调用setid使进程成为一个会话组长
     禁止进程重新打开控制终端
     关闭不再需要的文件描述符
     将当前目录更改为根目录
     将文件创建时使用的屏蔽字设置为0
     处理SIGCHLD 。可以简单地将SIGCHLD信号的操作设为SIG_IGN,这样子进程结束时不会产生僵尸进程

11.进程退出
        正常退出：exit _exit  return
        exit把控制权交给系统 ,同时执行一些清理操作，_exit立即返回到内核不执行清理操作，return把控制权交给函数
        异常退出：abort函数或是进程收到某个信号，而该信号使程序终止

12.执行新程序
    execv() execve() execl() execle() execvp() execlp() 正常情况下这些函数不会有返回值，如果有一个错误的事件，将会返回-1
    其中execve()是系统调用，参数path是将要执行的程序的路径名参数argv,envp 与main函数的argv,envp对应
    exec这些函数调用并没有生成新进程，一个进程一旦调用exec函数，系统把代码段替换成新的程序的代码，废弃原来的数据段和堆栈段，并为新程序分配新的数据段和堆栈段
    唯一保留的是进程ID
    exec这些函数执行可以是二进制的可执行文件，也可以是shell脚本，但必须是#!interpretername [arg]   如/bin/sh 或/bin/php
13.等待子进程结束
    wait函数：父进程一旦调用了wait就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。
    1 当父进程忘了用wait()函数等待已终止的子进程时,子进程就会进入一种无父进程的状态,此时子进程就是僵尸进程.
    2 wait()要与fork()配套出现,如果在使用fork()之前调用wait(),wait()的返回值则为-1,正常情况下wait()的返回值为子进程的PID.
    3 如果先终止父进程,子进程将继续正常进行，只是它将由init进程(PID 1)继承,当子进程终止时,init进程捕获这个状态.
    4 参数status用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。但如果我们对这个子进程是如何死掉毫不在意，只想把这个僵尸进程消灭掉，（事实上绝大多数情况下，我们都会这样想），我们就可以设定这个参数为NULL，就像下面这样：
    pid = wait(NULL);
    如果成功，wait会返回被收集的子进程的进程ID，如果调用进程没有子进程，调用就会失败，此时wait返回-1，同时errno被置为ECHILD。
    1，WIFEXITED(status)这个宏用来指出子进程是否为正常退出的，如果是，它会返回一个非零值。
    （请注意，虽然名字一样，这里的参数status并不同于wait唯一的参数–指向整数的指针status，而是那个指针所指向的整数，切记不要搞混了。）
    2， WEXITSTATUS(status)当WIFEXITED返回非零值时，我们可以用这个宏来提取子进程的返回值，如果子进程调用exit(5)退出，WEXITSTATUS(status)就会返回5；如果子进程调用exit(7)，WEXITSTATUS(status)就会返回7。请注意，如果进程不是正常退出的，也就是说，WIFEXITED返回0，这个值就毫无意义。
    waitpid函数：
    pid从本质上讲，系统调用waitpid和wait的作用是完全相同的，但waitpid多出了两个可由用户控制的参数pid和options，从而为我们编程提供了另一种更灵活的方式。下面我们就来详细介绍一下这两个参数：
    从参数的名字pid和类型pid_t中就可以看出，这里需要的是一个进程ID。但当pid取不同的值时，在这里有不同的意义。
    下面对pid的不同取值情况的说明：
    >0 表示回收指定ID的子进程
    -1  表示回收任意子进程（相当于wait）
    0 表示回收和当前调用waitpid一个组的所有子进程
    <-1 表示回收指定进程组内的任意子进程，比如-6610表示回收进程组id为6610的任意子进程
    附：一次wait或waitpid调用只能清理掉一个子进程，清理多个子进程应该使用循环调用多次 。
    Options
    参数options提供了一些额外的选项来控制waitpid，参数option可以为0或可以用"|"运算符把它们连接起来使用，比如：
    ret=waitpid(-1,NULL,WNOHANG | WUNTRACED);
    如果我们不想使用它们，也可以把options设为0，如：
    ret=waitpid(-1,NULL,0);
    WNOHANG 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若结束，则返回该子进程的ID。
    WUNTRACED 若子进程进入暂停状态，则马上返回，但子进程的结束状态不予以理会。WIFSTOPPED(status)宏确定返回值是否对应与一个暂停子进程。
    返回值和错误
    waitpid的返回值比wait稍微复杂一些，一共有3种情况：
    当正常返回的时候，waitpid返回收集到的子进程的进程ID
    如果设置了选项WNOHANG，而调用中waitpid发现没有已退出的子进程可收集，则返回0；
    如果调用中出错，则返回-1，这时errno会被设置成相应的值以指示错误所在；
    当pid所指示的子进程不存在，或此进程存在，但不是调用进程的子进程，waitpid就会出错返回，这时errno被设置为ECHILD；
14.经常其他操作
    getpid 获取进程id
    getgid 获取组id
    内核对进程存取文件的许可权检查，是通过考查进程的有效用户id来实现的

15.改变进程优先级
    nice ,getpriority ,getpriority
    nice 相当于执行
    int nice(int increment){
        int oldpro=getpriority(PRIO_PROCESS,getpid());
        return setpriority(PRIO_PROCESS,getpid(),oldpro+increment)
    }