

  1.线程与进程概念
  线程： 每个进程中至少包含一个线程，而这些线程都在共享进程的资源空间等，当线程发生变化的时候只会引起CPU执行的过程发生变化，不会改变进程所拥有的资源。同理一个程序中至少包含一个进程。进程中执行运算的最小单位，亦是执行处理机调度的基本单位
  进程： 每个进程都有自己的地址空间，资源如，内存，I/O,CPU，同一个进程里的 线程共享本进程里的地址空间，那能不能使用别人家进程的地址空间呢，显然这是不可以的。由于进程的独立性，当某一个进程崩溃之后，在保护模式下不会对别的进程进行影响。资源分配的基本单位，运行调度的基本单位，系统中并发执行的单位。
  2.使用区别
  当我们对资源的保护管理要求比较高的时候，建议使用多进程，当然存在的开销也会比较大，反过来，如果频繁切换下，对资源的保护管理要求不那么高，或者开销有限，使用多线程会比较方便。
  3.两者的比较
  （1）调度
  同一个进程中，线程的切换不会引起进程的切换；
  由一个进程的线程切换到另一个线程的进程时，引起进程的切换。
  （2）并发性
  进程可以并发执行，而一个进程中的线程也可以并发执行
  （3）拥有的资源
  一般来说，线程并不会拥有自己的资源，但是它可以访问自己本进程中的资源，比如，一个进程打开的文件等，进程的其他线程是可以共享的。
  4.进程是操作系统资源管理的最小单位，有标识号（非负整数）
  6.进程结构
    * 代码段 存储程序的可执行代码
    * 数据段 存放全局变量，常量，静态变量
    * 堆栈段 堆用于存放动态分配的内存变量， 栈用于存放函数参数，局部变量
  7.进程状态：
    R (运行状态)
    S（可中断等待状态）
    D(不可中断等待状态)
    T(停止状态)
    附加属性：<(高优先级进程) N（低优先级进程）L(内存锁页，即页不可以换出内存) s(该进程为会话首进程) l(多线程进程) +(进程位于前台进程)
 8.进程的内存映像
    从内存的低地址到高地址：代码段-》数据段-》未被初始化的数据段-》堆栈-》命令行参数和环境量
 9.孤儿进程
      如果一个子进程的父进程先于子进程结束，子进程就成为一个孤儿进程，它由init进程收养，称为init进程的子进程
 fork和vfork 区别：
     调用都有2次返回值
     fork子进程是父进程的一个拷贝。具体说，子进程从父进程那得到了数据段和堆栈段，但不是与父进程共享而是单独分配内存。fork函数返回后，子进程和父进程都是从fork函数的下一条语句开始执行。
     由于子进程与父进程的运行是无关的，父进程可先于子进程运行，子进程也可先于父进程运行
     vfork创建新进程的主要目的在于用exec函数执行另外的程序，实际上，在没调用exec或exit之前子进程的运行中是与父进程共享数据段的。
     在vfork调用中，子进程先运行，父进程挂起，直到子进程调用exec或exit，在这以后，父子进程的执行顺序不再有限制。vfork执行过程为：它产生的子进程刚开始暂时与父进程共享地址空间（其实就是线程的概念了），因为这时候子进程在父进程的地址空间中运行，所以子进程不能进行写操作，并且在儿子“霸占”着老子的房子时候，要委屈老子一下了，让他在外面歇着（阻塞），一旦儿子执行了exec或者exit后，相当于儿子买了自己的房子了，这时候就相当于分家了。
10.创建守护进程
     让进程在后台执行：方法是调用fork产生一个子进程，然后使得父进程退出
     调用setid创建一个新对话期。控制终端，登陆会话和进程组通常师父进程继承下来的，守护进程要摆脱它们，不受它们的影响，其方法是调用setid使进程成为一个会话组长
     禁止进程重新打开控制终端
     关闭不再需要的文件描述符
     将当前目录更改为根目录
     将文件创建时使用的屏蔽字设置为0
     处理SIGCHLD 。可以简单地将SIGCHLD信号的操作设为SIG_IGN,这样子进程结束时不会产生僵尸进程

11.进程退出
        正常退出：exit _exit  return
        exit把控制权交给系统 ,同时执行一些清理操作，_exit立即返回到内核不执行清理操作，return把控制权交给函数
        异常退出：abort函数或是进程收到某个信号，而该信号使程序终止

12.执行新程序
    execv() execve() execl() execle() execvp() execlp() 正常情况下这些函数不会有返回值，如果有一个错误的事件，将会返回-1
    其中execve()是系统调用，参数path是将要执行的程序的路径名参数argv,envp 与main函数的argv,envp对应
    exec这些函数调用并没有生成新进程，一个进程一旦调用exec函数，系统把代码段替换成新的程序的代码，废弃原来的数据段和堆栈段，并为新程序分配新的数据段和堆栈段
    唯一保留的是进程ID
    exec这些函数执行可以是二进制的可执行文件，也可以是shell脚本，但必须是#!interpretername [arg]   如/bin/sh 或/bin/php
