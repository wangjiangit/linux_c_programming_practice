1.如果函数没有明确指明返回类型,linux上gcc编译器默认返回int类型
2.一个函数的各个参数不可以重名，函数体内定义的变量也不可以与参数重名
3.函数可以返回一个指针但不可以返回一个数组，该数组在函数内部定义的,静态数组可以返回
4.函数可以嵌套调用但不可以嵌套定义
5.一个源文件通常由多个函数构成，如果某个变量不在任何函数内定义，则这个变量就是全局变量。
6.全局变量有限范围从定义处开始到文件的结束
7.事实上一对大括号{}标识一个变量的作用域
8.静态变量存储在静态存储区，程序运行结束后，才回收静态存储区
9.一个文件中如果全局变量的定义前使用该变量，按照C语言先定义后使用原则是不可以的，通过提前extern声明全局变量可以的
,告诉编译器该全局变量在别处定义了
10.如果一个源文件中代码要使用另一个源文件中定义的全局变量，就要使用extern 对该全局变量进行声明
11.数组定义元素个数必须是常量或常量表达式,可以初始化，但初始化时可以不用指定元素个数
12.在所有函数外定义的数组的所有元素将被自动赋予初值0，在函数内部定义的数组系统不会为其进行初始化，在使用数组元素前必须先对元素进行初始化
13.如果对二维元素都赋初值，则定义数组时第一维的维数可以省略，但第二维数必须指定，系统自动计算第一维数
14.可以用字符串初始化字符数组，同时应检查存储的字符串长度是否超过了字符数组的长度，否则很容易导致缓冲区溢出
15.避免使用未初始化的指针，在定义指针最好将它初始化位NULL，即明确指示当前该指针不指向任何变量
16.数组名实际就是指向数组第一个元素的指针
17.在没有超出数组范围的前提下，指向数组某个元素的指针上加上或减去一个整形数，就可以指向另外一个数组元素,
因为数组元素在逻辑上是按照顺序存放的
18. 在指针上进行加减运算后得到的指针，必须指向同一个数组或指向数组存储空间的下一个单元,当不能对数组存储空间下一个单元进行*取值操作
19.数组可以用下标的方式，也可以指针的方式.如：*(a+1)
20.不能对数组名执行++，--操作，因为数组的首地址的值在程序运行过程中是固定不变的常量
21.*p++:先取得当前p所指向的变量值再使p指向后一个变量，相当于a[i++]
22.*++p:先使p指向后一个变量再取得p所指向的变量的值,相当于a[++i]
23.int *p[3],由于运算符*的优先级低于运算符[],所有p和[3]结合，再与*结合，表示每个数组元素指向一个指向变量
24.指针数组名是个二级指针
25.区别 int(*p)[5] 和 int p[5] 前者是一个指针，它指向一个含有5个元素的数组，后者是一个数组，它长度为5，数组
中每一个元素指向一个整形变量
26. 如果一个函数的参数中有指针，那么处于程序的健壮性的考虑，在该函数中必须检查参数是否为NULL
27. 不能对指向函数的指针做任何运算 如p++,p-- ,p+n,p-n 都是错误的
28.指向函数的指针能通过同类型的函数名，函数指针或NULL来进行初始化或赋值。将函数指针初始为NULL表示指针不指向任何函数
29.返回函数指针的函数. 如 int (*fun1(int a))(int,int)
30.char *p ="Linux C" 和 char str[]="Linux C";  可以 str[1]='C' 不可 p[1]='C' 因为p[1]是常量
31.不能将一个而字符串常量或字符数组直接复制给另一个字符数组.字符串的复制只能使用strcpy类似功能的函数
如 char a[]="Linux C Program",b[20];  b=a 这样是错误的 ，应该 strcpy(b,a);
32.static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。
33.static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0
34.static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。
35.数组作为函数参数时，对系统来说，char str[100] 和char *str 是一样的
36.数组对越界访问是不会检查的，检查的任务由程序员自己来完成，所以不能对数组越界访问，否则导致严重错误
37.2个指针只有在所指向的数据类型一致时才可以相互赋值
38.const char* 和char*区别：
    char*是常量指针，地址不可以改变，但是指针的值可变。
    const char*是指向常量的常量指针，地址与值均不可变。
39.首先要搞清楚编译程序占用的内存的分区形式：
   一个由c/C++编译的程序占用的内存分为以下几个部分
   1、栈区（stack）—由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
   2、堆区（heap）—一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。
   3、全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。
   4、文字常量区—常量字符串就是放在这里的。程序结束后由系统释放。
   5、程序代码区
   int a=0; //全局初始化区
   char p1; //全局未初始化区
   main()
   {
   int b;栈
   char s[]=“abc”; //栈
   char p2; //栈
   char p3=“123456”; //123456\0在常量区，p3在栈上。
   static int c=0； //全局（静态）初始化区
   p1 = (char)malloc(10);
   p2 = (char)malloc(20); //分配得来得10和20字节的区域就在堆区。
   strcpy(p1,“123456”); //123456\0放在常量区，编译器可能会将它与p3指向的"123456"优化成一个地方。
   }
   首先，我们要知道
   char *a中的a是个指向字符类型的指针，这是一个变量；
   char a[]中的a也是一个指向字符类型的指针，但它是一个常量，常量是不能再给它赋值的，就像比不能写 3=2 这样的代码来给3赋值。
   通过阅读我们可以知道，char * a=“abc”和char a[]="abc"在内存中存放是有差别的，即char *a=“abc”中的“abc”是存放于字符常量区的，指针a只是指向了这个地址；
   char a[]="abc"中的“abc”其实是放在栈中的，它是字符常量区中“abc”的一份拷贝。
