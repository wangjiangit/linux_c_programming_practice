1.如果函数没有明确指明返回类型,linux上gcc编译器默认返回int类型
2.一个函数的各个参数不可以重名，函数体内定义的变量也不可以与参数重名
3.函数可以返回一个指针但不可以返回一个数组
4.函数可以嵌套调用但不可以嵌套定义
5.一个源文件通常由多个函数构成，如果某个变量不在任何函数内定义，则这个变量就是全局变量。
6.全局变量有限范围从定义处开始到文件的结束
7.事实上一对大括号{}标识一个变量的作用域
8.静态变量存储在静态存储区，程序运行结束后，才回收静态存储区
9.一个文件中如果全局变量的定义前使用该变量，按照C语言先定义后使用原则是不可以的，通过提前extern声明全局变量可以的
,告诉编译器该全局变量在别处定义了
10.如果一个源文件中代码要使用另一个源文件中定义的全局变量，就要使用extern 对该全局变量进行声明
11.数组定义元素个数必须是常量或常量表达式,可以初始化，但初始化时可以不用指定元素个数
12.在所有函数外定义的数组的所有元素将被自动赋予初值0，在函数内部定义的数组系统不会为其进行初始化，在使用数组元素前必须先对元素进行初始化
13.如果对二维元素都赋初值，则定义数组时第一维的维数可以省略，但第二维数必须指定，系统自动计算第一维数
14.可以用字符串初始化字符数组，同时应检查存储的字符串长度是否超过了字符数组的长度，否则很容易导致缓冲区溢出
15.避免使用未初始化的指针，在定义指针最好将它初始化位NULL，即明确指示当前该指针不指向任何变量
16.数组名实际就是指向数组第一个元素的指针
17.在没有超出数组范围的前提下，指向数组某个元素的指针上加上或减去一个整形数，就可以指向另外一个数组元素,
因为数组元素在逻辑上是按照顺序存放的
18. 在指针上进行加减运算后得到的指针，必须指向同一个数组或指向数组存储空间的下一个单元,当不能对数组存储空间下一个单元进行*取值操作
19.数组可以用下标的方式，也可以指针的方式.如：*(a+1)
20.不能对数组名执行++，--操作，因为数组的首地址的值在程序运行过程中是固定不变的常量
21.*p++:先取得当前p所指向的变量值再使p指向后一个变量，相当于a[i++]
22.*++p:先使p指向后一个变量再取得p所指向的变量的值,相当于a[++i]
23.int *p[3],由于运算符*的优先级低于运算符[],所有p和[3]结合，再与*结合，表示每个数组元素指向一个指向变量
24.指针数组名是个二级指针
25.区别 int(*p)[5] 和 int p[5] 前者是一个指针，它指向一个含有5个元素的数组，后者是一个数组，它长度为5，数组
中每一个元素指向一个整形变量
26. 如果一个函数的参数中有指针，那么处于程序的健壮性的考虑，在该函数中必须检查参数是否为NULL
27. 不能对指向函数的指针做任何运算 如p++,p-- ,p+n,p-n 都是错误的
28.指向函数的指针能通过同类型的函数名，函数指针或NULL来进行初始化或赋值。将函数指针初始为NULL表示指针不指向任何函数
29.返回函数指针的函数. 如 int (*fun1(int a))(int,int)
30.char *p ="Linux C" 和 char str[]="Linux C";  可以 str[1]='C' 不可 p[1]='C' 因为p[1]是常量
31.不能将一个而字符串常量或字符数组直接复制给另一个字符数组.字符串的复制只能使用strcpy类似功能的函数
如 char a[]="Linux C Program",b[20];  b=a 这样是错误的 ，应该 strcpy(b,a);
32.static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。
33.static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0
34.static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。